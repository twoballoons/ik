# 01编辑本段替换技巧

**实例目录**

【1】 正则表达式应用——替换指定内容到行尾

【2】 正则表达式应用——数字替换

【3】 正则表达式应用——删除每一行行尾的指定[字符](http://baike.baidu.com/view/263416.htm)

【4】 正则表达式应用——替换带有[半角](http://baike.baidu.com/view/517188.htm)括号的多行

【5】 正则表达式应用——删除空行

【6】 正则表达式应用——实例应用

**应用实例**

【1】正则表达式应用——替换指定内容到行尾

原始文本如下面两行

abc aaaaa

123 abc 444

希望每次遇到“abc”，则替换“abc”以及其后到行尾的内容为“abc efg”

即上面的文本最终替换为：

abc efg

123 abc efg

解决：

① 在替换对话框，查找内容里输入“abc.\*”，替换内容输入为“abc efg”

② 同时勾选“正则表达式”[复选框](http://baike.baidu.com/view/1143823.htm)，然后点击“全部替换”按钮

其中，符号的含义如下：

“.” =匹配任意[字符](http://baike.baidu.com/view/263416.htm)

“\*” =匹配0次或更多

注意：其实就是正则表达式替换，这里只是把一些曾经提出的问题加以整理，单纯从正则表达式本身来说，就可以引申出成千上万种特例。

【2】正则表达式应用——数字替换

希望把

asdadas123asdasdas456asdasdasd789asdasd

替换为:

asdadas\[123\]asdasdas\[456\]asdasdasd\[789\]asdasd

在替换对话框里面，勾选“正则表达式”[复选框](http://baike.baidu.com/view/1143823.htm)；

在查找内容里面输入“(\[0-9\])(\[0-9\])(\[0-9\])”，不含引号

“替换为:”里面输入“\[\\1\\2\\3\]”，不含引号

####备注####：查找（\[0-9\]+） 替换：\[\\1\] 更简单通用些

范围为你所操作的范围，然后选择替换即可。

实际上这也是正则表达式的使用特例，“\[0-9\]”表示匹配0～9之间的任何特例，同样“\[a-z\]”就表示匹配a～z之间的任何特例

上面重复使用了“\[0-9\]”，表示连续出现的三个数字

括号用来选择原型，进行分组，替换时要用

“\\1”代表第一个“\[0-9\]”对应的原型，“\\2”代表第二个“\[0-9\]”对应的原型，依此类推

“\[”、“\]”为单纯的[字符](http://baike.baidu.com/view/263416.htm)，表示添加“\[”或“\]”，如果输入“其它\\1\\2\\3其它”，则替换结果为：

asdadas其它123其它asdasdas其它456其它asdasdasd其它789其它asdasd

功能增强：

如果将查找内容“\[0-9\]\[0-9\]\[0-9\]”改为“\[0-9\]\*\[0-9\]”，对应1 或 123 或 12345 或 ...

大家根据需要定制

相关内容还有很多，可以自己参考正则表达式的语法仔细研究一下

【3】正则表达式应用——删除每一行行尾的指定[字符](http://baike.baidu.com/view/263416.htm)

因为这几个[字符](http://baike.baidu.com/view/263416.htm)在行中也是出现的,所以肯定不能用简单的替换实现

比如

12345 1265345

2345

需要删除每行末尾的“345”

这个也算正则表达式的用法，其实仔细看正则表达式应该比较简单，不过既然有这个问题提出，说明对正则表达式还得有个认识过程，解决方法如下

解决：

在替换对话框中，启用“正则表达式”[复选框](http://baike.baidu.com/view/1143823.htm)

在查找内容里面输入“345\$”

这里“\$”表示从行尾匹配

如果从行首匹配，可以用“^”来实现，不过 EditPlus 有另一个功能可以很简单的删除行首的字符串

a. 选择要操作的行

b. 编辑－格式－删除行注释

c. 在弹出对话框里面输入要清除的行首[字符](http://baike.baidu.com/view/263416.htm)，确定

【4】正则表达式应用——替换带有半角括号的多行

几百个网页中都有下面一段代码：

我想把它们都去掉，可是找了很多search & replace的软件，都是只能对“一行”进行操作。

EditPlus 打开几百个网页文件还是比较顺畅的，所以完全可以胜任这个工作。

具体解决方法，在 Editplus 中[使用正则表达式](http://baike.baidu.com/view/1091115.htm)，由于“(”、“)”被用做预设表达式（或者可以称作子表达式）的标志，所以查找

“\\n\\n\\n”

时会提示查找不到，所以也就无法进行替换了，这时可以把“(”、“)”使用任意[字符](http://baike.baidu.com/view/263416.htm)标记替代，即[半角](http://baike.baidu.com/view/517188.htm)句号：“.”。替换内容为

\\\\n\\\\n\\\\n

在替换对话框启用“正则表达式”选项，这时就可以完成替换了

补充：

对( ) 这样的特殊符号，应该用\\( \\)来表示，这也是很标准的regexp语法，可以写为

\\\\n\\\\n\\\\n

【5】正则表达式应用——删除空行

启动EditPlus，打开待处理的文本类型文件。

①、选择“查找”[菜单](http://baike.baidu.com/view/102616.htm)的“替换”命令，弹出[文本替换](http://baike.baidu.com/view/893270.htm)对话框。选中“正则表达式”[复选框](http://baike.baidu.com/view/1143823.htm)，表明我们要在查找、替换中[使用正则表达式](http://baike.baidu.com/view/1091115.htm)。然后，选中“替换范围”中的“[当前文件](http://baike.baidu.com/view/4356266.htm)”，表明对当前文件操作。

②、单击“查找内容”[组合框](http://baike.baidu.com/view/1436669.htm)右侧的按钮，出现下拉菜单。

③、下面的操作添加正则表达式，该表达式代表待查找的空行。（技巧提示：空行仅包括[空格符](http://baike.baidu.com/view/2159122.htm)、[制表符](http://baike.baidu.com/view/1138182.htm)、回车符，且必须以这三个符号之一作为一行的开头，并且以回车符结尾，查找空行的关键是构造代表空行的正则表达式）。

直接在"查找"中输入正则表达式“^\[ \\t\]\*\\n”，注意\\t前有[空格符](http://baike.baidu.com/view/2159122.htm)。

（1）选择“从行首开始匹配”，“查找内容”[组合框](http://baike.baidu.com/view/1436669.htm)中出现字符“^”，表示待查找字符串必须出现在[文本](http://baike.baidu.com/view/300107.htm)中一行的行首。

（2）选择“[字符](http://baike.baidu.com/view/263416.htm)在范围中”，那么在“^”后会增加一对括号“\[\]”，当前[插入点](http://baike.baidu.com/view/1245723.htm)在括号中。括号在正则表达式中表示，文本中的[字符](http://baike.baidu.com/view/263416.htm)匹配括号中任意一个字符即符合查找条件。

（3）按一下[空格键](http://baike.baidu.com/view/559836.htm)，添加[空格符](http://baike.baidu.com/view/2159122.htm)。[空格符](http://baike.baidu.com/view/2159122.htm)是空行的一个组成成分。

（4）选择“[制表符](http://baike.baidu.com/view/1138182.htm)”，添加代表制表符的“\\t”。

（5）移动[光标](http://baike.baidu.com/view/236729.htm)，将当前[插入点](http://baike.baidu.com/view/1245723.htm)移到“\]”之后，然后选择“匹配 0 次或更多”，该操作会添加星号字符“\*”。星号表示，其前面的括号“\[\]”内的[空格符](http://baike.baidu.com/view/2159122.htm)或[制表符](http://baike.baidu.com/view/1138182.htm)，在一行中出现0个或多个。

（6）选择“换行符”，插入“\\n”，表示回车符。

④、“替换为”[组合框](http://baike.baidu.com/view/1436669.htm)保持空，表示删除查找到的内容。单击“替换”按钮逐个行删除空行，或单击“全部替换”按钮删除全部空行（注意：EditPlus有时存在“全部替换”不能一次性完全删除空行的问题，可能是程序BUG，需要多按几次按钮）。

【6】 正则表达式应用——实例应用

1.验证用户名和密码：（"^\[a-zA-Z\]\\w{5,15}\$"）正确格式："\[A-Z\]\[a-z\]\_\[0-9\]"组成,并且第一个字必须为字母6\~16位；

2.验证电话号码：（"^(\\d{3,4}-)\\d{7,8}\$"）正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx；

3.验证身份证号（15位或18位数字）：（"^\\d{15}|\\d{18}\$"）；

4.验证Email地址：("^\\w+(\[-+.\]\\w+)\*@\\w+(\[-.\]\\w+)\*\\.\\w+(\[-.\]\\w+)\*\$")；

5.只能输入由数字和26个英文字母组成的字符串：("^\[A-Za-z0-9\]+\$") ;

6.整数或者小数：^\[0-9\]+\\.{0,1}\[0-9\]{0,2}\$

7.只能输入数字："^\[0-9\]\*\$"。

8.只能输入n位的数字："^\\d{n}\$"。

9.只能输入至少n位的数字："^\\d{n,}\$"。

10.只能输入m\~n位的数字：。"^\\d{m,n}\$"

11.只能输入零和非零开头的数字："^(0|\[1-9\]\[0-9\]\*)\$"。

12.只能输入有两位小数的正实数："^\[0-9\]+(.\[0-9\]{2})?\$"。

13.只能输入有1\~3位小数的正实数："^\[0-9\]+(.\[0-9\]{1,3})?\$"。

14.只能输入非零的正整数："^\\+?\[1-9\]\[0-9\]\*\$"。

15.只能输入非零的负整数："^\\-\[1-9\]\[\]0-9"\*\$。

16.只能输入长度为3的字符："^.{3}\$"。

17.只能输入由26个英文字母组成的字符串："^\[A-Za-z\]+\$"。

18.只能输入由26个大写英文字母组成的字符串："^\[A-Z\]+\$"。

19.只能输入由26个小写英文字母组成的字符串："^\[a-z\]+\$"。

20.验证是否含有^%&',;=?\$\\"等字符："\[^%&',;=?\$\\x22\]+"。

21.只能输入汉字："^\[\\u4e00-\\u9fa5\]{0,}\$"

22.验证URL："^http://(\[\\w-\]+\\.)+\[\\w-\]+(/\[\\w-./?%&=\]\*)?\$"。

23.验证一年的12个月："^(0?\[1-9\]|1\[0-2\])\$"正确格式为："01"～"09"和"1"～"12"。

24.验证一个月的31天："^((0?\[1-9\])|((1|2)\[0-9\])|30|31)\$"正确格式为；"01"～"09"和"1"～"31"。

25.获取日期正则表达式：\\d{4}\[年|\\-|\\.\]\\d{\\1-\\12}\[月|\\-|\\.\]\\d{\\1-\\31}日?

评注：可用来匹配大多数年月日信息。

26.匹配双[字节](http://baike.baidu.com/view/60408.htm)[字符](http://baike.baidu.com/view/263416.htm)(包括汉字在内)：\[^\\x00-\\xff\]

评注：可以用来计算[字符](http://baike.baidu.com/view/263416.htm)串的长度（一个双[字节](http://baike.baidu.com/view/60408.htm)字符长度计2，ASCII字符计1）

27.匹配空白行的正则表达式：\\n\\s\*\\r

评注：可以用来删除空白行

28.匹配HTML标记的正则表达式：<(\\S\*?)\[^>\]\*>.\*?</>|<.\*? />

评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力

29.匹配首尾空白[字符](http://baike.baidu.com/view/263416.htm)的正则表达式：^\\s\*|\\s\*\$

评注：可以用来删除行首行尾的空白[字符](http://baike.baidu.com/view/263416.htm)(包括空格、[制表符](http://baike.baidu.com/view/1138182.htm)、换页符等等)，非常有用的表达式

30.匹配网址URL的正则表达式：\[a-zA-z\]+://\[^\\s\]\*

评注：网上流传的版本功能很有限，上面这个基本可以满足需求

31.匹配帐号是否合法(字母开头，允许5-16[字节](http://baike.baidu.com/view/60408.htm)，允许字母数字下划线)：^\[a-zA-Z\]\[a-zA-Z0-9\_\]{4,15}\$

评注：表单验证时很实用

32.匹配腾讯QQ号：\[1-9\]\[0-9\]\\{4,\\}

评注：腾讯QQ号从000 0 开始

33.匹配中国邮政编码：\[1-9\]\\d{5}(?!\\d)

评注：中国邮政编码为6位数字

34.匹配ip地址：((2\[0-4\]\\d|25\[0-5\]|\[01\]?\\d\\d?)\\.){3}(2\[0-4\]\\d|25\[0-5\]|\[01\]?\\d\\d?)。

评注：提取ip地址时有用

Function IsRegu(Regu,s)

'正则表达式校验

If Regu="" Then

Exit Function

End if

Dim Re,Sre

Set Re = New RegExp

Re.Pattern = Regu

Sre = Re.Test(s)

If Sre = True Then

IsRegu = True

Else

IsRegu = False

End If

End Function

tmp=" "

if (IsRegu("\\w+(\[-+.\]\\w+)\*@\\w+(\[-.\]\\w+)\*\\.\\w+(\[-.\]\\w+)\*",tmp )) =false then

msgbox "E-mail地址不合法 ！"

FieldCheck#N=false

end if

不同的语言（如PHP和JAVA）、相同语言的不同类库（如来自Sun的Java Regular Expression类库跟Apache Jakarta的正则表达式类库）间，用法会有所差别，在使用的时候，要注意这些差别。

**验证URL**

function IsValidUrl(str) {\[5\]

var regu = "^(https?://)"

  + "?((\[0-9a-z\_!~~\*'().&=+\$%-\]+: )?\[0-9a-z\_!~~\*'().&=+\$%-\]+@)?"
  + "((\[0-9\]{1,3}\\.){3}\[0-9\]{1,3}"
  + "|"
  + "(\[0-9a-z\_!~~\*'()-\]+\\.)\*"~~\~\~　　+ "(\[0-9a-z\]\[0-9a-z-\]{0,61})?\[0-9a-z\]\\."\~\~
    \~\~　　+ "\[a-z\]{2,6})"\~\~
    \~\~　　+ "(:\[0-9\]{1,4})?"\~\~
    \~\~　　+ "((/?)|"\~\~
    \~\~　　+ "(/\[0-9a-z\_!\~\~\*'().;?:@&=+\$,%#-\]+)+/?)\$";\[5\]　　var re = new RegExp(regu);
    　　if (!re.test(str)) {
    　　return false;
    　　}
    　　return true;
    　　}

# 02编辑本段启示

（1） 心中时刻保持新颖想法，尝试用各种新办法来解决遇到的问题。对于遇到的问题，在用常规的解决思路无法解决或不能很好解决的时候，可以大胆探索尝试采用新的方法或思路来解决问题，说大点就是创新！没有新思路估计今天的正则表达式还要等几百年才能露现人间。

（2） 善于学习和借鉴前人的经验和成果，UNIX鼻祖Ken Thompson是什么样子的人？是被计算机界尊称为“UNIX之父”的大师级别的人物，大师都在不断思考从其它学科、其它知识领域的工作成果，来改进自己的工作或程序，事实也证明这样做取得巨大结果和后来的深远影响是事先谁也无法预估到的，我们在做一些事情或研究的时间，是否也考虑学习大师的优秀习惯？

（3） 学好数学、英语并保持对数学、英语的兴趣，数学也是人类几千年积累的智慧结晶，学习数学知识可以培养和训练人的思维能力。看这篇文章的朋友，我想很多都是[计算机相关专业](http://baike.baidu.com/view/5446025.htm)的朋友，至于数学和英语对于计算机学习和发展的重要性的道理，这里就不在多说，重在实践加持之以恒！

（4） 养成独立思考的习惯。上学时候老师经常说人与动物的最大区别是人能思考。拉美洲有句关于“思考”的谚语是，不会思考的人是白痴，不肯思考的人是懒汉，不敢思考的人是奴隶。我想大家和我一样，既不愿做懒汉、奴隶，更不愿做白痴。所以相信正则分享网的朋友们一定会选择做一个“会思、肯思、敢思”的人。

（5） 当正则表达式和字符串函数都能解决问题时，一定要使用字符串函数，这样不容易出错，最重要的是字符串函数比正则表达式实现性能上要好得多。\[1\]

# 03编辑本段教程

**正则表达式教程**chm完整版是一本详细介绍了正则表达式的电子书教程，全书共分为8个小节，详细的讲述了正则表达式的定义，各种操作符的运算优先级，全部符号解释，正则表达式匹配规则，参考文献以及相关实例等，全书简明呃要，能够很好的帮助读者们正确常握学习好正则表达式，从而在软件编程中得到更好的发挥。\[6\]

# 正则

| 元字符       | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| \\           | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配字符“n”。“\\\\n”匹配一个换行符。序列“\\\\”匹配“\\”而“\\(”则匹配“(”。 |
| ^            | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。 |
| \$           | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，\$也匹配“\\n”或“\\r”之前的位置。 |
| \*           | 匹配前面的子表达式零次或多次。例如，zo\*能匹配“z”以及“zoo”。\*等价于{0,}。 |
| +            | 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 |
| ?            | 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 |
| {n}          | n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 |
| {n,}         | n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o\*”。 |
| {n,m}        | m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 |
| ?            | 当该字符紧跟在任何一个其他限制符（\*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 |
| .点          | 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“\[\\s\\S\]”的模式。 |
| (pattern)    | 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用\$0…\$9属性。要匹配圆括号字符，请使用“\\(”或“\\)”。 |
| (?:pattern)  | 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“( |
| (?=pattern)  | 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95 |
| (?!pattern)  | 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95 |
| (?<=pattern) | 反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?<=95 |
| (?<!pattern) | 反向否定预查，与正向否定预查类似，只是方向相反。例如“(?<!95  |
| x            | y                                                            |
| \[xyz\]      | 字符集合。匹配所包含的任意一个字符。例如，“\[abc\]”可以匹配“plain”中的“a”。 |
| \[^xyz\]     | 负值字符集合。匹配未包含的任意字符。例如，“\[^abc\]”可以匹配“plain”中的“plin”。 |
| \[a-z\]      | 字符范围。匹配指定范围内的任意字符。例如，“\[a-z\]”可以匹配“a”到“z”范围内的任意小写字母字符。<br>注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出现在字符组的开头,则只能表示连字符本身. |
| \[^a-z\]     | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“\[^a-z\]”可以匹配任何不在“a”到“z”范围内的任意字符。 |
| \\b          | 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 |
| \\B          | 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 |
| \\cx         | 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 |
| \\d          | 匹配一个数字字符。等价于\[0-9\]。                            |
| \\D          | 匹配一个非数字字符。等价于\[^0-9\]。                         |
| \\f          | 匹配一个换页符。等价于\\x0c和\\cL。                          |
| \\n          | 匹配一个换行符。等价于\\x0a和\\cJ。                          |
| \\r          | 匹配一个回车符。等价于\\x0d和\\cM。                          |
| \\s          | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于\[ \\f\\n\\r\\t\\v\]。 |
| \\S          | 匹配任何非空白字符。等价于\[^ \\f\\n\\r\\t\\v\]。            |
| \\t          | 匹配一个制表符。等价于\\x09和\\cI。                          |
| \\v          | 匹配一个垂直制表符。等价于\\x0b和\\cK。                      |
| \\w          | 匹配包括下划线的任何单词字符。等价于“\[A-Za-z0-9\_\]”。      |
| \\W          | 匹配任何非单词字符。等价于“\[^A-Za-z0-9\_\]”。               |
| \\xn         | 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04&1”。正则表达式中可以使用ASCII编码。 |
| \\num        | 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。 |
| \\n          | 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 |
| \\nm         | 标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。 |
| \\nml        | 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 |
| \\un         | 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 |

最简单的[元字符](http://baike.baidu.com/view/1061241.htm)是点，它能够匹配任何单个字符（注意不包括换行符）。假定有个文件test.txt包含以下几行内容：

he is a[rat](http://baike.baidu.com/view/369708.htm)

he is in a rut

the food is Rotten

I like root beer

我们可以使用grep命令来测试我们的正则表达式，grep命令[使用正则表达式](http://baike.baidu.com/view/1091115.htm)去尝试匹配指定文件的每一行，并将至少有一处匹配表达式的所有行显示出来。命令

*grep r.t test.txt*

在test.txt文件中的每一行中搜索正则表达式r.t，并打印输出匹配的行。正则表达式r.t匹配一个r接着任何一个字符再接着一个t。所以它将匹配文件中的[rat](http://baike.baidu.com/view/369708.htm)和rut，而不能匹配Rotten中的Rot，因为正则表达式是大小写敏感的。要想同时匹配大写和小写字母，应该使用[字符](http://baike.baidu.com/view/263416.htm)区间[元字符](http://baike.baidu.com/view/1061241.htm)（方括号）。正则表达式\[Rr\]能够同时匹配R和r。所以，要想匹配一个大写或者小写的r接着任何一个字符再接着一个t就要使用这个表达式：\[Rr\].t。

要想匹配行首的字符要使用抑扬字符（^）——有时也被叫做插入符。例如，想找到text.txt中行首"he"打头的行，你可能会先用简单表达式he，但是这会匹配第三行的the，所以要[使用正则表达式](http://baike.baidu.com/view/1091115.htm)^he，它只匹配在行首出现的h。

有时候指定“除了×××都匹配”会比较容易达到目的，当抑扬字符（^）出现在方括号中时，它表示“排除”，例如要匹配he ，但是排除前面是t or s的情形（也就是the和she），可以使用：\[^st\]he。

可以使用方括号来指定多个字符区间。例如正则表达式\[A-Za-z\]匹配任何字母，包括大写和小写的；正则表达式\[A-Za-z\]\[A-Za-z\]\* 匹配一个字母后面接着0或者多个字母（大写或者小写）。当然我们也可以用[元字符](http://baike.baidu.com/view/1061241.htm)+做到同样的事情，也就是：\[A-Za-z\]+ ，和\[A-Za-z\]\[A-Za-z\]\*完全等价。但是要注意[元字符](http://baike.baidu.com/view/1061241.htm)+ 并不是所有支持正则表达式的程序都支持的。关于这一点可以参考后面的正则表达式语法支持情况。

要指定特定数量的匹配，要使用大括号（注意必须使用[反斜杠](http://baike.baidu.com/view/572694.htm)来转义）。想匹配所有10和100的实例而排除1和 1000，可以使用：10\\{1,2\\}，这个正则表达式匹配数字1后面跟着1或者2个0的模式。在这个[元字符](http://baike.baidu.com/view/1061241.htm)的使用中一个有用的变化是忽略第二个数字，例如正则表达式0\\{3,\\} 将匹配至少3个连续的0。

这里有一些有代表性的、比较简单的例子。

| **vi** **命令**             | **作用**                                                     |
| --------------------------- | ------------------------------------------------------------ |
| :%s/ \*/ /g                 | 把一个或者多个空格替换为一个空格                             |
| :%s/ \*\$//                 | 去掉行尾的所有空格                                           |
| :%s/^/ /                    | 在每一行头上加入一个空格                                     |
| :%s/^\[0-9\]\[0-9\]\* //    | 去掉行首的所有数字字符                                       |
| :%s/b\[aeio\]g/bug/g        | 将所有的bag、beg、big和bog改为bug。                          |
| :%s/t\\(\[aou\]\\)g/h\\1t/g | 将所有tag、tog和tug分别改为hat、hot和hut（注意用group的用法和使用\\1引用前面被匹配的字符） |

**例1**

将所有方法foo(a,b,c)的实例改为foo(b,a,c)。这里a、b和c可以是任何提供给方法foo()的参数。也就是说我们要实现这样的转换：

之前 之后

foo(10,7,2) foo(7,10,2)

foo(x+13,y-2,10) foo(y-2,x+13,10)

foo( bar(8), x+y+z, 5) foo( x+y+z, bar(8), 5)

下面这条替换命令能够实现这一魔法：

*:%s/foo(\\(\[^,\]\*\\),\\(\[^,\]\*\\),\\(\[^)\]\*\\))/foo(\\2,\\1,\\3)/g*

现在让我们把它打散来加以分析。写出这个表达式的基本思路是找出foo()和它的括号中的三个参数的位置。第一个参数是用这个表达式来识别的：：\\(\[^,\]\*\\)，我们可以从里向外来分析它：

\[^,\] 除了逗号之外的任何字符

\[^,\]\* 0或者多个非逗号字符

\\(\[^,\]\*\\) 将这些非逗号字符标记为\\1，这样可以在之后的替换模式表达式中引用它

\\(\[^,\]\*\\), 我们必须找到0或者多个非逗号[字符](http://baike.baidu.com/view/263416.htm)后面跟着一个逗号，并且非逗号字符那部分要标记出来以备后用。

现在正是指出一个[使用正则表达式](http://baike.baidu.com/view/1091115.htm)常见错误的最佳时机。为什么我们要使用\[^,\]\*这样的一个表达式，而不是更加简单直接的写法，例如：.\*，来匹配第一个参数呢？设想我们使用模式.\*来匹配字符串"10,7,2"，它应该匹配"10,"还是"10,7,"？为了解决这个两义性（ambiguity），正则表达式规定一律按照最长的串来，在上面的例子中就是"10,7,"，显然这样就找出了两个参数而不是我们期望的一个。所以，我们要使用\[^,\]\*来强制取出第一个逗号之前的部分。

这个表达式我们已经分析到了：foo(\\(\[^,\]\*\\)，这一段可以简单的翻译为“当你找到foo(就把其后直到第一个逗号之前的部分标记为\\1”。然后我们使用同样的办法标记第二个参数为\\2。对第三个参数的标记方法也是一样，只是我们要搜索所有的字符直到右括号。我们并没有必要去搜索第三个参数，因为我们不需要调整它的位置，但是这样的模式能够保证我们只去替换那些有三个参数的foo()方法调用，在foo()是一个[重载](http://baike.baidu.com/view/126530.htm)（overloading）方法时这种明确的模式往往是比较保险的。然后，在替换部分，我们找到foo()的对应实例，然后利用标记好的部分进行替换，是把第一和第二个参数交换位置。

**例2**

假设有一个CSV（comma separated value）文件，里面有一些我们需要的信息，但是格式却有问题，目前数据的列顺序是：姓名，公司名，州名缩写，邮政编码，现在我们希望将这些数据重新组织，以便在我们的某个软件中使用，需要的格式为：姓名，州名缩写-邮政编码，公司名。也就是说，我们要调整列顺序，还要合并两个列来构成一个新列。另外，我们的软件不能接受逗号前后有任何空格（包括空格和[制表符](http://baike.baidu.com/view/1138182.htm)）所以我们还必须要去掉逗号前后的所有空格。

这里有几行我们现在的数据：

Bill Jones, HI-TEK Corporation , CA, 95011

Sharon Lee Smith, Design Works Incorporated, CA, 95012

B. Amos , Hill Street Cafe, CA, 95013

Alexander Weatherworth, The Crafts Store, CA, 95014

...

我们希望把它变成这个样子：

Bill Jones,CA 95011,HI-TEK Corporation

Sharon Lee Smith,CA 95012,Design Works Incorporated

B. Amos,CA 95013,Hill Street Cafe

Alexander Weatherworth,CA 95014,The Crafts Store

...

我们将用两个正则表达式来解决这个问题。第一个移动列和合并列，第二个用来去掉空格。

下面就是第一个替换命令：

*:%s/\\(\[^,\]\*\\),\\(\[^,\]\*\\),\\(\[^,\]\*\\),\\(.\*\\)/\\1,\\3 \\4,\\2/*

这里的方法跟例1基本一样，第一个列（姓名）用这个表达式来匹配：\\(\[^,\]\*\\)，即第一个逗号之前的所有字符，而姓名内容被用\\1标记下来。公司名和州名缩写字段用同样的方法标记为\\2和\\3，而最后一个字段用\\(.\*\\)来匹配（"匹配所有字符直到行末"）。替换部分则引用上面标记的那些内容来进行构造。

下面这个替换命令则用来去除空格：

*:%s/\[ \\t\]\*,\[ \\t\]\*/,/g*

我们还是分解来看：\[ \\t\]匹配空格/[制表符](http://baike.baidu.com/view/1138182.htm)，\[ \\t\]\* 匹配0或多个空格/制表符，\[ \\t\]\*,匹配0或多个空格/制表符后面再加一个逗号，最后，\[ \\t\]\*,\[ \\t\]\*匹配0或多个空格/制表符接着一个逗号再接着0或多个空格/制表符。在替换部分，我们简单的我们找到的所有东西替换成一个逗号。这里我们使用了结尾的可选的g参数，这表示在每行中对所有匹配的串执行替换（而不是缺省的只替换第一个匹配串）。

**例3**

假设有一个多字符的片断重复出现，例如：

Billy tried really hard

Sally tried really really hard

Timmy tried really really really hard

Johnny tried really really really really hard

而你想把"really"、"really really"，以及任意数量连续出现的"really"字符串换成一个简单的"very"（simple is good!），那么以下命令：

*:%s/\\(really \\)\\(really \\)\*/very /*

就会把上述的文本变成：

Billy tried very hard

Sally tried very hard

Timmy tried very hard

Johnny tried very hard

表达式\\(really \\)\*匹配0或多个连续的"really "（注意结尾有个空格），而\\(really \\)\\(really \\)\* 匹配1个或多个连续的"really "实例。

**正则表达式语法支持情况**

|                |       |           |       |        |             |             |       |       |      |      |
| -------------- | ----- | --------- | ----- | ------ | ----------- | ----------- | ----- | ----- | ---- | ---- |
| **命令或环境** | **.** | **\[ \]** | **^** | **\$** | **\\( \\)** | **\\{ \\}** | **?** | **+** | **   | **   |
| **vi**         | √     | √         | √     | √      | √           |             |       |       |      |      |
| **Visual C++** | √     | √         | √     | √      | √           |             |       |       |      |      |
| **awk**        | √     | √         | √     | √      |             |             | √     | √     | √    | √    |
| **sed**        | √     | √         | √     | √      | √           | √           |       |       |      |      |
| **Tcl**        | √     | √         | √     | √      | √           |             | √     | √     | √    | √    |
| **ex**         | √     | √         | √     | √      | √           | √           |       |       |      |      |
| **grep**       | √     | √         | √     | √      | √           | √           |       |       |      |      |
| **egrep**      | √     | √         | √     | √      | √           |             | √     | √     | √    | √    |
| **fgrep**      | √     | √         | √     | √      | √           |             |       |       |      |      |
| **perl**       | √     | √         | √     | √      | √           |             | √     | √     | √    | √    |
| **C#**         |       |           |       |        | √           | √           |       |       |      |      |

